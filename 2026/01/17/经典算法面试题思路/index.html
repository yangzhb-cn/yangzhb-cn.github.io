<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>经典算法面试题思路 | 在秩序中远行</title><meta name="author" content="杨志彬"><meta name="copyright" content="杨志彬"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数组 704. 二分查找     给定一个按升序排列的整数数组 nums 和目标值 target，在数组中查找 target，若存在返回其索引，否则返回 -1。   34. 在排序数组中查找元素的第一个和最后一个位置     给定一个按升序排列的整数数组 nums 和目标值 target，返回 target 在数组中的起始位置和结束位置；若不存在返回 [-1, -1]。  双指针：采用左闭右开写法">
<meta property="og:type" content="article">
<meta property="og:title" content="经典算法面试题思路">
<meta property="og:url" content="https://yangzhb-cn.github.io/2026/01/17/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%B7%AF/index.html">
<meta property="og:site_name" content="在秩序中远行">
<meta property="og:description" content="数组 704. 二分查找     给定一个按升序排列的整数数组 nums 和目标值 target，在数组中查找 target，若存在返回其索引，否则返回 -1。   34. 在排序数组中查找元素的第一个和最后一个位置     给定一个按升序排列的整数数组 nums 和目标值 target，返回 target 在数组中的起始位置和结束位置；若不存在返回 [-1, -1]。  双指针：采用左闭右开写法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yangzhb-cn.github.io/img/2153815987697221632.jpg">
<meta property="article:published_time" content="2026-01-17T09:21:57.000Z">
<meta property="article:modified_time" content="2026-01-16T19:38:53.029Z">
<meta property="article:author" content="杨志彬">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yangzhb-cn.github.io/img/2153815987697221632.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "经典算法面试题思路",
  "url": "https://yangzhb-cn.github.io/2026/01/17/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%B7%AF/",
  "image": "https://yangzhb-cn.github.io/img/2153815987697221632.jpg",
  "datePublished": "2026-01-17T09:21:57.000Z",
  "dateModified": "2026-01-16T19:38:53.029Z",
  "author": [
    {
      "@type": "Person",
      "name": "杨志彬",
      "url": "https://yangzhb-cn.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yangzhb-cn.github.io/2026/01/17/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%B7%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '经典算法面试题思路',
  isHighlightShrink: undefined,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/2581793565608771584.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/2244933495988158464.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 整理</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 索引</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 资源</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fasfa-link"></i><span> 参考</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fasfa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/2153815987697221632.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">在秩序中远行</span></a><a class="nav-page-title" href="/"><span class="site-name">经典算法面试题思路</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 整理</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 索引</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 资源</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fasfa-link"></i><span> 参考</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fasfa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">经典算法面试题思路</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-17T09:21:57.000Z" title="发表于 2026-01-17 17:21:57">2026-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-16T19:38:53.029Z" title="更新于 2026-01-17 03:38:53">2026-01-17</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li><strong>704. 二分查找</strong></li>
</ul>
<blockquote>
<p>  给定一个按升序排列的整数数组 <code>nums</code> 和目标值 <code>target</code>，在数组中查找 <code>target</code>，若存在返回其索引，否则返回 <code>-1</code>。</p>
</blockquote>
<ul>
<li><strong>34. 在排序数组中查找元素的第一个和最后一个位置</strong></li>
</ul>
<blockquote>
<p>  给定一个按升序排列的整数数组 <code>nums</code> 和目标值 <code>target</code>，返回 <code>target</code> 在数组中的起始位置和结束位置；若不存在返回 <code>[-1, -1]</code>。</p>
</blockquote>
<p>双指针：采用左闭右开写法。不要在二分过程时一旦找到目标值就立刻返回。有更好的解法，可以找到最小的满足 nums[i] &gt;&#x3D; target 的 i</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针：</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; <span class="comment">// 闭区间 [left, right]</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 区间不为空</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">		left = mid + <span class="number">1</span>; <span class="comment">// 范围缩小到 [mid+1, right]</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		right = mid - <span class="number">1</span>; <span class="comment">// 范围缩小到 [left, mid-1]</span></span><br><span class="line">	&#125; <span class="comment">// 结束循环后此时范围为[right,left]，由于right是对应&gt;= ，就是说上一步 == 的情况也会使 right 发生变化，因此选择left</span></span><br><span class="line">	 <span class="comment">// 没有直接return是为了找到最小的满足 nums[i] &gt;= target 的 i</span></span><br><span class="line">	<span class="keyword">return</span> left; <span class="comment">// 或者 right+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在排序数组中查找元素的第一个和最后一个位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> lowerBound(nums, target);</span><br><span class="line">	<span class="keyword">if</span> (start == nums.length || nums[start] != target) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;; <span class="comment">// nums 中没有 target</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果 start 存在，那么 end 必定存在</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> lowerBound(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p><strong>27. 移除元素</strong></p>
<blockquote>
<p>给定数组 <code>nums</code> 和值 <code>val</code>，原地移除所有等于 <code>val</code> 的元素，并返回移除后数组的新长度（元素顺序可改变）。</p>
</blockquote>
</li>
<li><p><strong>88. 合并两个有序数组</strong></p>
<blockquote>
<p>给定两个按非递减顺序排列的数组 <code>nums1</code> 和 <code>nums2</code>（其中 <code>nums1</code> 预留空间），将 <code>nums2</code> 合并到 <code>nums1</code> 中，使合并后仍为非递减顺序。</p>
</blockquote>
</li>
<li><p><strong>977. 有序数组的平方</strong></p>
<blockquote>
<p>给定一个按非递减顺序排列的整数数组 <code>nums</code>，返回每个元素平方后的数组，并按非递减顺序排列。</p>
</blockquote>
</li>
<li><p><strong>209. 长度最小的子数组</strong></p>
<blockquote>
<p>给定正整数数组 <code>nums</code> 和正整数 <code>target</code>，找出和大于等于 <code>target</code> 的长度最小的连续子数组并返回其长度；若不存在返回 <code>0</code>。</p>
</blockquote>
</li>
<li><p><strong>3. 无重复字符的最长子串</strong></p>
<blockquote>
<p>给定字符串 <code>s</code>，找出不含重复字符的最长子串长度。</p>
</blockquote>
</li>
<li><p><strong>713. 乘积小于 K 的子数组</strong></p>
<blockquote>
<p>给定正整数数组 <code>nums</code> 和整数 <code>k</code>，返回乘积严格小于 <code>k</code> 的连续子数组的个数。</p>
</blockquote>
</li>
<li><p><strong>59. 螺旋矩阵 II</strong></p>
<blockquote>
<p>给定正整数 <code>n</code>，生成一个 <code>n x n</code> 矩阵，按顺时针螺旋顺序填入从 <code>1</code> 到 <code>n^2</code> 的整数。</p>
</blockquote>
</li>
</ul>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul>
<li><p><strong>203. 移除链表元素</strong></p>
<blockquote>
<p>给定一个链表的头节点 <code>head</code> 和一个整数 <code>val</code>，删除链表中所有节点值等于 <code>val</code> 的节点，并返回新的头节点。</p>
</blockquote>
</li>
<li><p><strong>707. 设计链表</strong></p>
<blockquote>
<p>设计并实现链表结构，支持获取指定索引节点值、在头部&#x2F;尾部&#x2F;指定位置插入节点、删除指定位置节点等操作。</p>
</blockquote>
</li>
<li><p><strong>206. 反转链表</strong></p>
<blockquote>
<p>给定单链表的头节点 <code>head</code>，将链表反转，并返回反转后的头节点。</p>
</blockquote>
</li>
<li><p><strong>92. 反转链表 II</strong></p>
<blockquote>
<p>给定单链表头节点 <code>head</code> 和两个整数 <code>left</code>、<code>right</code>，将链表中从位置 <code>left</code> 到位置 <code>right</code> 的节点进行反转，并返回反转后的链表。</p>
</blockquote>
</li>
<li><p><strong>25. K 个一组反转链表</strong></p>
<blockquote>
<p>给定链表头节点 <code>head</code> 和整数 <code>k</code>，每 <code>k</code> 个节点一组进行反转，返回反转后的链表；不足 <code>k</code> 个的部分保持原顺序。</p>
</blockquote>
</li>
<li><p><strong>24. 两两交换链表中的节点</strong></p>
<blockquote>
<p>给定链表头节点 <code>head</code>，两两交换相邻节点并返回交换后的链表（不能只修改节点值，需实际交换节点）。</p>
</blockquote>
</li>
<li><p><strong>19. 删除链表的倒数第 N 个节点</strong></p>
<blockquote>
<p>给定链表头节点 <code>head</code> 和整数 <code>n</code>，删除链表的倒数第 <code>n</code> 个节点，并返回新的头节点。</p>
</blockquote>
</li>
<li><p><strong>237. 删除链表中的节点</strong></p>
<blockquote>
<p>给定需要被删除的节点 <code>node</code>（不是头节点），在无法访问头节点的情况下删除该节点。</p>
</blockquote>
</li>
<li><p><strong>82. 删除排序链表中的重复元素 II</strong></p>
<blockquote>
<p>给定一个已排序的链表头节点 <code>head</code>，删除所有出现重复的节点（重复值的节点全部移除），只保留不重复的节点，返回新的头节点。</p>
</blockquote>
</li>
<li><p><strong>面试题 02.07. 链表相交</strong></p>
<blockquote>
<p>给定两个单链表的头节点 <code>headA</code> 和 <code>headB</code>，判断两链表是否相交；若相交返回第一个相交节点，否则返回 <code>null</code>。</p>
</blockquote>
</li>
<li><p><strong>141. 环形链表</strong></p>
<blockquote>
<p>给定链表头节点 <code>head</code>，判断链表中是否存在环，存在返回 <code>true</code>，否则返回 <code>false</code>。</p>
</blockquote>
</li>
<li><p><strong>142. 环形链表 II</strong></p>
<blockquote>
<p>给定链表头节点 <code>head</code>，若链表存在环，返回环的入口节点；若不存在环，返回 <code>null</code>。</p>
</blockquote>
</li>
<li><p><strong>143. 重排链表</strong></p>
<blockquote>
<p>给定链表头节点 <code>head</code>，将链表重排为 <code>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...</code>，并要求原地完成。</p>
</blockquote>
</li>
</ul>
<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><ul>
<li><p><strong>242. 有效的字母异位词</strong></p>
<blockquote>
<p>给定两个字符串 <code>s</code> 和 <code>t</code>，判断 <code>t</code> 是否是 <code>s</code> 的字母异位词（包含相同字符且各字符出现次数相同）。</p>
</blockquote>
</li>
<li><p><strong>349. 两个数组的交集</strong></p>
<blockquote>
<p>给定两个整数数组 <code>nums1</code> 和 <code>nums2</code>，返回它们的交集（结果中的每个元素必须唯一）。</p>
</blockquote>
</li>
<li><p><strong>202. 快乐数</strong></p>
<blockquote>
<p>给定一个整数 <code>n</code>，反复将其替换为各位数字平方和；如果最终变为 <code>1</code> 则为快乐数，否则会进入循环不是快乐数。</p>
</blockquote>
</li>
<li><p><strong>1. 两数之和</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>target</code>，返回两个下标，使得它们对应的数字之和等于 <code>target</code>（假设恰好有一个解，且同一元素不能重复使用）。</p>
</blockquote>
</li>
<li><p><strong>454. 四数相加 II</strong></p>
<blockquote>
<p>给定四个整数数组 <code>nums1、nums2、nums3、nums4</code>，计算有多少个元组 <code>(i,j,k,l)</code> 使得 <code>nums1[i] + nums2[j] + nums4[l] + nums3[k] == 0</code>。</p>
</blockquote>
</li>
<li><p><strong>383. 赎金信</strong></p>
<blockquote>
<p>给定字符串 <code>ransomNote</code> 和 <code>magazine</code>，判断 <code>ransomNote</code> 能否由 <code>magazine</code> 中的字符构成（每个字符只能使用一次）。</p>
</blockquote>
</li>
<li><p><strong>15. 三数之和</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code>，返回所有不重复的三元组 <code>[nums[i], nums[j], nums[k]]</code>，使其和为 <code>0</code>。</p>
</blockquote>
</li>
<li><p><strong>18. 四数之和</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>target</code>，返回所有不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code>，使其和等于 <code>target</code>。</p>
</blockquote>
</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><p><strong>344. 反转字符串</strong></p>
<blockquote>
<p>给定一个字符数组 <code>s</code>，将其原地反转。</p>
</blockquote>
</li>
<li><p><strong>541. 反转字符串 II</strong></p>
<blockquote>
<p>给定字符串 <code>s</code> 和整数 <code>k</code>，每计数到 <code>2k</code> 个字符，就反转前 <code>k</code> 个字符；如果剩余少于 <code>k</code> 个则全部反转，介于 <code>k</code> 和 <code>2k</code> 之间则反转前 <code>k</code> 个。</p>
</blockquote>
</li>
<li><p><strong>剑指 Offer 05. 替换空格</strong></p>
<blockquote>
<p>给定字符串 <code>s</code>，把字符串中的每个空格替换成 <code>&quot;%20&quot;</code>，返回替换后的字符串。</p>
</blockquote>
</li>
<li><p><strong>剑指 Offer 58-II. 左旋转字符串</strong></p>
<blockquote>
<p>给定字符串 <code>s</code> 和整数 <code>n</code>，将字符串左旋转 <code>n</code> 位（把前 <code>n</code> 个字符移动到字符串末尾）。</p>
</blockquote>
</li>
</ul>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><ul>
<li><p><strong>28. 实现 strStr()</strong></p>
<blockquote>
<p>给定两个字符串 <code>haystack</code> 和 <code>needle</code>，在 <code>haystack</code> 中找出 <code>needle</code> 第一次出现的下标；若不存在返回 <code>-1</code>（当 <code>needle</code> 为空时返回 <code>0</code>）。</p>
</blockquote>
</li>
<li><p><strong>459. 重复的子字符串</strong></p>
<blockquote>
<p>给定非空字符串 <code>s</code>，判断它是否可以由它的某个子串重复多次构成。</p>
</blockquote>
</li>
<li><p><strong>232. 用栈实现队列</strong></p>
<blockquote>
<p>仅使用两个栈实现一个队列，支持 <code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code> 等操作。</p>
</blockquote>
</li>
<li><p><strong>225. 用队列实现栈</strong></p>
<blockquote>
<p>仅使用队列实现一个栈，支持 <code>push</code>、<code>pop</code>、<code>top</code>、<code>empty</code> 等操作。</p>
</blockquote>
</li>
<li><p><strong>20. 有效的括号</strong></p>
<blockquote>
<p>给定只包含 <code>&#39;(&#39;、&#39;)&#39;、&#39;{&#39;、&#39;}&#39;、&#39;[&#39;、&#39;]&#39;</code> 的字符串 <code>s</code>，判断括号是否有效（需正确闭合且顺序正确）。</p>
</blockquote>
</li>
<li><p><strong>1047. 删除字符串中的所有相邻重复项</strong></p>
<blockquote>
<p>给定字符串 <code>s</code>，反复删除相邻且相同的字符对，直到无法继续删除，返回最终字符串。</p>
</blockquote>
</li>
<li><p><strong>150. 逆波兰表达式求值</strong></p>
<blockquote>
<p>给定一个表示逆波兰表达式的字符串数组 <code>tokens</code>，计算表达式的值（运算符包含 <code>+ - * /</code>）。</p>
</blockquote>
</li>
<li><p><strong>239. 滑动窗口最大值</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code> 和窗口大小 <code>k</code>，返回每个滑动窗口中的最大值组成的数组。</p>
</blockquote>
</li>
<li><p><strong>347. 前 K 个高频元素</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，返回出现频率前 <code>k</code> 高的元素（返回顺序不限）。</p>
</blockquote>
</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul>
<li><strong>104. 二叉树的最大深度</strong></li>
</ul>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，返回其最大深度（从根到最远叶子节点的节点数）。</p>
</blockquote>
<ul>
<li><strong>111. 二叉树的最小深度</strong></li>
</ul>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，返回其最小深度（从根到最近叶子节点的最短路径节点数）。</p>
</blockquote>
<ul>
<li><p><strong>222. 完全二叉树的节点个数</strong></p>
<blockquote>
<p>给定一棵完全二叉树的根节点 <code>root</code>，返回该树的节点个数。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 104.二叉树的最大深度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="comment">//f(1)</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// gf(n-1)</span></span><br><span class="line">	<span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 111.二叉树的最小深度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="comment">// f(0)</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// gf(n-1) 此时还不是叶子节点，这是个坑</span></span><br><span class="line">	<span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.min(minDepth(root.right),minDepth(root.left)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 222. 完全二叉树的节点个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="comment">// 左子树节点 + 右子树节点 + 当前节点</span></span><br><span class="line">	<span class="comment">// if(root == null)&#123;</span></span><br><span class="line">	<span class="comment">// return 0;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// return countNodes(root.left) + countNodes(root.right) + 1;</span></span><br><span class="line">	<span class="comment">// 没有把完全二叉树特性利用：完美二叉树的话节点个数等于2^h - 1，其中h是根节点高度</span></span><br><span class="line">	<span class="comment">// 完全二叉树的节点个数计算，这里有个小优化，计算满二叉树的节点个数</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">lNode</span> <span class="operator">=</span> root, rNode = root;</span><br><span class="line">	<span class="type">int</span> <span class="variable">lDepth</span> <span class="operator">=</span> <span class="number">0</span>, rDepth = <span class="number">0</span>; <span class="comment">// 分别计算左右子树的高度</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (lNode != <span class="literal">null</span>) &#123;</span><br><span class="line">		lDepth++;</span><br><span class="line">		lNode = lNode.left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (rNode != <span class="literal">null</span>) &#123;</span><br><span class="line">		rDepth++;</span><br><span class="line">		rNode = rNode.right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 满二叉树</span></span><br><span class="line">	<span class="keyword">if</span> (lDepth == rDepth) &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; lDepth) - <span class="number">1</span>; <span class="comment">// 2^n - 1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 其余情况按普通完全二叉树计算(计算完全二叉树时，又会优化成一个分支走满二叉树计算)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong>144. 二叉树的前序遍历</strong></li>
</ul>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，返回其节点值的前序遍历结果（根-左-右）。</p>
</blockquote>
<ul>
<li><strong>94. 二叉树的中序遍历</strong></li>
</ul>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，返回其节点值的中序遍历结果（左-根-右）。</p>
</blockquote>
<ul>
<li><strong>145. 二叉树的后序遍历</strong></li>
</ul>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，返回其节点值的后序遍历结果（左-右-根）。</p>
</blockquote>
<ul>
<li><strong>98. 验证二叉搜索树</strong></li>
</ul>
<blockquote>
<p>给定二叉树根节点 <code>root</code>，判断其是否为有效的二叉搜索树。</p>
</blockquote>
<ul>
<li><p>就是考虑节点非边界条件A与递归（B1，B2）的顺序</p>
<ul>
<li>前序遍历A-B1-B2，表现为自顶向下</li>
<li>中序遍历B1-A-B2，对于二叉搜索树的中序遍历是严格单调递增的</li>
<li>后序遍历B1-B2-A，表现为自底向上</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>100. 相同的树</strong></p>
<blockquote>
<p>给定两棵二叉树的根节点 <code>p</code> 和 <code>q</code>，判断它们是否在结构和节点值上完全相同。</p>
</blockquote>
</li>
<li><p><strong>101. 对称二叉树</strong></p>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，判断它是否是轴对称的。</p>
</blockquote>
</li>
<li><p><strong>226. 翻转二叉树</strong></p>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，翻转这棵二叉树，并返回其根节点。</p>
</blockquote>
</li>
<li><p><strong>110. 平衡二叉树</strong></p>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，判断该树是否为平衡二叉树（任意节点左右子树高度差不超过 1）。</p>
</blockquote>
</li>
<li><p><strong>199. 二叉树的右视图</strong></p>
<blockquote>
<p>给定一个二叉树的 根节点<code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
</blockquote>
</li>
<li><p><strong>257. 二叉树的所有路径</strong></p>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，返回从根节点到所有叶子节点的路径字符串列表。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//100. 相同的树 </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">	<span class="comment">// 边界条件</span></span><br><span class="line">	<span class="keyword">if</span>( p == <span class="literal">null</span> || q == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> p == q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非边界条件</span></span><br><span class="line">	<span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  101.对称二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="comment">// 直接思考递归不好想，要换个思路，判断左树是否等于右树，这里是指轴对称的左右树</span></span><br><span class="line">	<span class="comment">// 以及左树的左边等于右树右边，左树右边等于右树左边</span></span><br><span class="line">	<span class="keyword">return</span> isSameTree(root.left,root.right);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似相同的树，但是要改成镜像判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">	<span class="comment">// 边界条件</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> p == q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非边界条件</span></span><br><span class="line">	<span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.right) &amp;&amp; isSameTree(p.right, q.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 226. 反转二叉树</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="comment">//两个节点（同一个父节点）进行一次左右交换，直到这两个节点同时为空返回</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(root);</span><br><span class="line">	invertTree(root.left);</span><br><span class="line">	invertTree(root.right);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">	root.left = root.right;</span><br><span class="line">	root.right = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 110.平衡二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="comment">// 边界条件</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取当前层的非边界条件：左右子树高度差不超过1</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> Math.abs(high(root.left) - high(root.right));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> balance &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算当前节点高度</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">high</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.max(high(root.right),high(root.left)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 199.二叉树的右视图</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="comment">// 希望只想遍历当层的最右边，BFS？</span></span><br><span class="line">	<span class="comment">// 递推怎么弄，从右子树开始遍历，自上而下（前序遍历）</span></span><br><span class="line">	<span class="comment">// 递推时，深度+1时添加到链表中，因此需要保存当前深度</span></span><br><span class="line">	List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	rightSideView1(root,res,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">rightSideView1</span><span class="params">(TreeNode root, List&lt;Integer&gt; res,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// 非边界条件</span></span><br><span class="line">	<span class="comment">// 用参数 depth 表示当前层，并用 res.size() 判断“这一层是否已加入过元素”。不需要任何全局变量。</span></span><br><span class="line">	<span class="keyword">if</span>(res.size() == depth)&#123;</span><br><span class="line">		res.add(root.val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历下一层</span></span><br><span class="line">	rightSideView1(root.right,res,depth+<span class="number">1</span>);</span><br><span class="line">	rightSideView1(root.left,res,depth+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>想法：采用前序遍历思想，自顶而下递归，非边界条件为判断当前节点条件，并考虑是否需要传递信息给下一层，使用临时变量进行保存，如平衡二叉树的balance，右视图的depth、保存的链表大小
</code></pre>
<hr>
<ul>
<li><p><strong>404. 左叶子之和</strong></p>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，返回所有左叶子节点值之和。</p>
</blockquote>
</li>
<li><p><strong>513. 找树左下角的值</strong></p>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，返回树最底层最左边节点的值。</p>
</blockquote>
</li>
<li><p><strong>112. 路径总和</strong></p>
<blockquote>
<p>给定二叉树的根节点 <code>root</code> 和目标和 <code>targetSum</code>，判断是否存在从根到叶子节点的路径，使路径上节点值之和等于 <code>targetSum</code>。</p>
</blockquote>
</li>
<li><p><strong>106. 从中序与后序遍历序列构造二叉树</strong></p>
<blockquote>
<p>给定二叉树的中序遍历数组 <code>inorder</code> 和后序遍历数组 <code>postorder</code>，构造并返回该二叉树。</p>
</blockquote>
</li>
<li><p><strong>654. 最大二叉树</strong></p>
<blockquote>
<p>给定不含重复元素的整数数组 <code>nums</code>，按“最大值为根、左侧构建左子树、右侧构建右子树”的规则构造并返回最大二叉树。</p>
</blockquote>
</li>
<li><p><strong>617. 合并二叉树</strong></p>
<blockquote>
<p>给定两棵二叉树的根节点 <code>root1</code> 和 <code>root2</code>，将两棵树合并成一棵新树：重叠节点值相加，非重叠节点直接使用原节点。</p>
</blockquote>
</li>
<li><p><strong>700. 二叉搜索树中的搜索</strong></p>
<blockquote>
<p>给定二叉搜索树根节点 <code>root</code> 和值 <code>val</code>，在 BST 中查找值为 <code>val</code> 的节点并返回其子树根节点；若不存在返回 <code>null</code>。</p>
</blockquote>
</li>
<li><p><strong>102. 二叉树的层序遍历</strong></p>
<blockquote>
<p>给定二叉树的根节点 <code>root</code>，按层返回节点值的遍历结果。</p>
</blockquote>
</li>
<li><p><strong>530. 二叉搜索树的最小绝对差</strong></p>
<blockquote>
<p>给定二叉搜索树根节点 <code>root</code>，返回任意两节点值之间的最小绝对差。</p>
</blockquote>
</li>
<li><p><strong>501. 二叉搜索树中的众数</strong></p>
<blockquote>
<p>给定二叉搜索树根节点 <code>root</code>，返回所有出现频率最高的元素（众数）。</p>
</blockquote>
</li>
<li><p><strong>236. 二叉树的最近公共祖先</strong></p>
<blockquote>
<p>给定二叉树根节点 <code>root</code> 和两个节点 <code>p</code>、<code>q</code>，返回它们的最近公共祖先节点。</p>
</blockquote>
</li>
<li><p><strong>235. 二叉搜索树的最近公共祖先</strong></p>
<blockquote>
<p>给定二叉搜索树根节点 <code>root</code> 和两个节点 <code>p</code>、<code>q</code>，返回它们的最近公共祖先节点。</p>
</blockquote>
</li>
<li><p><strong>701. 二叉搜索树中的插入操作</strong></p>
<blockquote>
<p>给定二叉搜索树根节点 <code>root</code> 和要插入的值 <code>val</code>，将 <code>val</code> 插入 BST 并返回插入后的根节点。</p>
</blockquote>
</li>
<li><p><strong>450. 删除二叉搜索树中的节点</strong></p>
<blockquote>
<p>给定二叉搜索树根节点 <code>root</code> 和键值 <code>key</code>，删除 BST 中值等于 <code>key</code> 的节点，并返回新的根节点。</p>
</blockquote>
</li>
<li><p><strong>669. 修剪二叉搜索树</strong></p>
<blockquote>
<p>给定二叉搜索树根节点 <code>root</code> 和边界 <code>low</code>、<code>high</code>，修剪树使所有节点值都在 <code>[low, high]</code> 范围内，返回修剪后的根节点。</p>
</blockquote>
</li>
<li><p><strong>108. 将有序数组转换为二叉搜索树</strong></p>
<blockquote>
<p>给定一个按升序排列的整数数组 <code>nums</code>，将其转换为一棵高度平衡的二叉搜索树并返回根节点。</p>
</blockquote>
</li>
<li><p><strong>538. 把二叉搜索树转换为累加树</strong></p>
<blockquote>
<p>给定二叉搜索树根节点 <code>root</code>，将其转换为累加树，使每个节点的值变为原值加上所有大于它的节点值之和。</p>
</blockquote>
</li>
</ul>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul>
<li><p><strong>77. 组合</strong></p>
<blockquote>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
</blockquote>
</li>
<li><p><strong>216. 组合总和 III</strong></p>
<blockquote>
<p>找出所有由 <code>1</code> 到 <code>9</code> 中 <code>k</code> 个不同数字组成、且数字和为 <code>n</code> 的组合（每个数字最多使用一次）。</p>
</blockquote>
</li>
<li><p><strong>17. 电话号码的字母组合</strong></p>
<blockquote>
<p>给定仅包含数字 <code>2-9</code> 的字符串 <code>digits</code>，返回它能表示的所有可能的字母组合。</p>
</blockquote>
</li>
<li><p><strong>39. 组合总和</strong></p>
<blockquote>
<p>给定一个无重复元素数组 <code>candidates</code> 和目标值 <code>target</code>，返回所有和为 <code>target</code> 的组合（同一数字可无限次使用）。</p>
</blockquote>
</li>
<li><p><strong>40. 组合总和 II</strong></p>
<blockquote>
<p>给定一个可能包含重复元素的数组 <code>candidates</code> 和目标值 <code>target</code>，返回所有和为 <code>target</code> 的组合（每个数字最多使用一次，结果不能重复）。</p>
</blockquote>
</li>
<li><p><strong>131. 分割回文串</strong></p>
<blockquote>
<p>给定字符串 <code>s</code>，将 <code>s</code> 分割成若干子串，使每个子串都是回文串，返回所有可能的分割方案。</p>
</blockquote>
</li>
<li><p><strong>93. 复原 IP 地址</strong></p>
<blockquote>
<p>给定只包含数字的字符串 <code>s</code>，返回所有可能的有效 IP 地址组合（需要插入三个点）。</p>
</blockquote>
</li>
<li><p><strong>78. 子集</strong></p>
<blockquote>
<p>给定一个不含重复元素的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</p>
</blockquote>
</li>
<li><p><strong>90. 子集 II</strong></p>
<blockquote>
<p>给定一个可能包含重复元素的整数数组 <code>nums</code>，返回所有可能的子集（不能包含重复子集）。</p>
</blockquote>
</li>
<li><p><strong>491. 递增子序列</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code>，返回所有不同的递增子序列（长度至少为 2，允许相等即非递减）。</p>
</blockquote>
</li>
<li><p><strong>46. 全排列</strong></p>
<blockquote>
<p>给定一个不含重复元素的整数数组 <code>nums</code>，返回其所有可能的全排列。</p>
</blockquote>
</li>
<li><p><strong>47. 全排列 II</strong></p>
<blockquote>
<p>给定一个可能包含重复元素的整数数组 <code>nums</code>，返回所有不重复的全排列。</p>
</blockquote>
</li>
<li><p><strong>51. N 皇后</strong></p>
<blockquote>
<p>给定整数 <code>n</code>，返回所有不同的 <code>n</code> 皇后问题的解决方案（在 <code>n×n</code> 棋盘上放置 <code>n</code> 个皇后且互不攻击）。</p>
</blockquote>
</li>
<li><p><strong>37. 解数独</strong></p>
<blockquote>
<p>编写程序填充 <code>9×9</code> 的数独，使其满足数独规则（每行、每列、每个 <code>3×3</code> 宫内数字 <code>1-9</code> 不重复）。</p>
</blockquote>
</li>
</ul>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><ul>
<li><p><strong>455. 分发饼干</strong></p>
<blockquote>
<p>给定孩子的胃口值数组 <code>g</code> 和饼干尺寸数组 <code>s</code>，每个孩子最多分到一块饼干，若饼干尺寸不小于胃口则孩子满足；返回最多能满足的孩子数量。</p>
</blockquote>
</li>
<li><p><strong>376. 摆动序列</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code>，返回最长摆动子序列的长度（相邻差值正负交替）。</p>
</blockquote>
</li>
<li><p><strong>53. 最大子序和</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code>，找出具有最大和的连续子数组，并返回该最大和。</p>
</blockquote>
</li>
<li><p><strong>122. 买卖股票的最佳时机 II</strong></p>
<blockquote>
<p>给定股票价格数组 <code>prices</code>，可进行多次交易（同一时间只能持有一股），返回可获得的最大利润。</p>
</blockquote>
</li>
<li><p><strong>55. 跳跃游戏</strong></p>
<blockquote>
<p>给定非负整数数组 <code>nums</code>，<code>nums[i]</code> 表示从位置 <code>i</code> 最远可跳跃的步数，判断是否能到达最后一个下标。</p>
</blockquote>
</li>
<li><p><strong>45. 跳跃游戏 II</strong></p>
<blockquote>
<p>给定非负整数数组 <code>nums</code>，<code>nums[i]</code> 表示从位置 <code>i</code> 最远可跳跃的步数，返回到达最后一个下标的最少跳跃次数。</p>
</blockquote>
</li>
<li><p><strong>1005. K 次取反后最大化的数组和</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，每次可选择一个元素取反，最多进行 <code>k</code> 次操作，返回数组元素和的最大值。</p>
</blockquote>
</li>
<li><p><strong>134. 加油站</strong></p>
<blockquote>
<p>给定两个数组 <code>gas</code> 和 <code>cost</code>，<code>gas[i]</code> 为第 <code>i</code> 个加油站油量，<code>cost[i]</code> 为从 <code>i</code> 到 <code>i+1</code> 消耗；若能绕行一周返回起始站下标，否则返回 <code>-1</code>。</p>
</blockquote>
</li>
<li><p><strong>135. 分发糖果</strong></p>
<blockquote>
<p>给定数组 <code>ratings</code> 表示孩子评分，需给每个孩子至少 1 颗糖，且评分更高的孩子比相邻孩子糖更多；返回需要的最少糖果数。</p>
</blockquote>
</li>
<li><p><strong>860. 柠檬水找零</strong></p>
<blockquote>
<p>在柠檬水售价 5 元的情况下，按顾客付款顺序（5&#x2F;10&#x2F;20）找零，判断能否对每位顾客正确找零。</p>
</blockquote>
</li>
<li><p><strong>406. 根据身高重建队列</strong></p>
<blockquote>
<p>给定数组 <code>people</code>，每个元素为 <code>[h, k]</code> 表示身高 <code>h</code>、前面身高 ≥ <code>h</code> 的人数为 <code>k</code>，重建并返回队列。</p>
</blockquote>
</li>
<li><p><strong>452. 用最少数量的箭引爆气球</strong></p>
<blockquote>
<p>给定二维数组 <code>points</code> 表示气球直径区间 <code>[xstart, xend]</code>，一支箭在 <code>x</code> 位置可引爆所有包含 <code>x</code> 的气球，返回引爆所有气球的最少箭数。</p>
</blockquote>
</li>
<li><p><strong>435. 无重叠区间</strong></p>
<blockquote>
<p>给定区间数组 <code>intervals</code>，移除最少数量的区间，使剩余区间互不重叠，返回需要移除的数量。</p>
</blockquote>
</li>
<li><p><strong>763. 划分字母区间</strong></p>
<blockquote>
<p>给定字符串 <code>s</code>，将其划分为尽可能多的片段，使每个字母最多出现在一个片段中，返回每个片段的长度列表。</p>
</blockquote>
</li>
<li><p><strong>56. 合并区间</strong></p>
<blockquote>
<p>给定区间数组 <code>intervals</code>，合并所有重叠区间并返回合并后的区间数组。</p>
</blockquote>
</li>
<li><p><strong>738. 单调递增的数字</strong></p>
<blockquote>
<p>给定整数 <code>n</code>，返回小于等于 <code>n</code> 的最大整数，使其各位数字满足单调递增（从左到右非递减）。</p>
</blockquote>
</li>
<li><p><strong>968. 监控二叉树</strong></p>
<blockquote>
<p>给定二叉树根节点 <code>root</code>，在树上放置最少的摄像头，使每个节点都被监控（摄像头可监控自身、父节点和子节点）。</p>
</blockquote>
</li>
</ul>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><p><strong>509. 斐波那契数</strong></p>
<blockquote>
<p>给定整数 <code>n</code>，返回第 <code>n</code> 个斐波那契数。</p>
</blockquote>
</li>
<li><p><strong>70. 爬楼梯</strong></p>
<blockquote>
<p>给定整数 <code>n</code>，每次可爬 1 或 2 阶，返回爬到第 <code>n</code> 阶的不同方法数。</p>
</blockquote>
</li>
<li><p><strong>746. 使用最小花费爬楼梯</strong></p>
<blockquote>
<p>给定数组 <code>cost</code>，<code>cost[i]</code> 为踏上第 <code>i</code> 阶的花费，可从 0 或 1 开始，每次走 1 或 2 阶，返回到达楼顶的最小花费。</p>
</blockquote>
</li>
<li><p><strong>1049. 最后一块石头的重量 II</strong></p>
<blockquote>
<p>给定石头重量数组 <code>stones</code>，每次选两块相撞（规则同题意），返回可能剩下的最小重量。</p>
</blockquote>
</li>
<li><p><strong>494. 目标和</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>target</code>，在每个数前添加 <code>+</code> 或 <code>-</code>，返回使表达式结果等于 <code>target</code> 的方法数。</p>
</blockquote>
</li>
<li><p><strong>474. 一和零</strong></p>
<blockquote>
<p>给定二进制字符串数组 <code>strs</code> 和整数 <code>m</code>、<code>n</code>，在最多使用 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 的限制下，返回可选取字符串的最大数量。</p>
</blockquote>
</li>
<li><p><strong>279. 完全平方数</strong></p>
<blockquote>
<p>给定整数 <code>n</code>，返回和为 <code>n</code> 的完全平方数的最少数量。</p>
</blockquote>
</li>
<li><p><strong>139. 单词拆分</strong></p>
<blockquote>
<p>给定字符串 <code>s</code> 和字符串字典 <code>wordDict</code>，判断 <code>s</code> 是否能由字典中的单词拼接而成（单词可重复使用）。</p>
</blockquote>
</li>
<li><p><strong>198. 打家劫舍</strong></p>
<blockquote>
<p>给定非负整数数组 <code>nums</code> 表示每间房的金额，不能偷相邻房屋，返回可偷到的最大金额。</p>
</blockquote>
</li>
<li><p><strong>213. 打家劫舍 II</strong></p>
<blockquote>
<p>给定环形排列的房屋金额数组 <code>nums</code>，不能偷相邻房屋，返回可偷到的最大金额。</p>
</blockquote>
</li>
<li><p><strong>337. 打家劫舍 III</strong></p>
<blockquote>
<p>给定一棵二叉树（节点值为金额），不能同时偷父子节点，返回可偷到的最大金额。</p>
</blockquote>
</li>
<li><p><strong>121. 买卖股票的最佳时机</strong></p>
<blockquote>
<p>给定股票价格数组 <code>prices</code>，最多进行一次买卖，返回最大利润。</p>
</blockquote>
</li>
<li><p><strong>122. 买卖股票的最佳时机 II</strong></p>
<blockquote>
<p>给定股票价格数组 <code>prices</code>，可进行多次交易（同一时间只能持有一股），返回最大利润。</p>
</blockquote>
</li>
<li><p><strong>123. 买卖股票的最佳时机 III</strong></p>
<blockquote>
<p>给定股票价格数组 <code>prices</code>，最多进行两次交易，返回最大利润。</p>
</blockquote>
</li>
<li><p><strong>62. 不同路径</strong></p>
<blockquote>
<p>机器人从左上角到右下角，只能向右或向下移动，给定 <code>m</code> 和 <code>n</code>，返回不同路径数量。</p>
</blockquote>
</li>
<li><p><strong>63. 不同路径 II</strong></p>
<blockquote>
<p>与不同路径类似，但网格中有障碍物，返回从左上到右下的不同路径数量（无法到达则为 0）。</p>
</blockquote>
</li>
<li><p><strong>416. 分割等和子集</strong></p>
<blockquote>
<p>给定只包含正整数的数组 <code>nums</code>，判断是否可以将数组分割成两个子集，使两个子集元素和相等。</p>
</blockquote>
</li>
<li><p><strong>518. 零钱兑换 II</strong></p>
<blockquote>
<p>给定不同面额硬币 <code>coins</code> 和金额 <code>amount</code>，返回凑成 <code>amount</code> 的组合数（每种硬币数量无限）。</p>
</blockquote>
</li>
<li><p><strong>377. 组合总和 IV</strong></p>
<blockquote>
<p>给定不同整数数组 <code>nums</code> 和目标值 <code>target</code>，返回和为 <code>target</code> 的组合数（不同顺序视为不同组合）。</p>
</blockquote>
</li>
<li><p><strong>322. 零钱兑换</strong></p>
<blockquote>
<p>给定不同面额硬币 <code>coins</code> 和金额 <code>amount</code>，返回凑成 <code>amount</code> 所需的最少硬币数；若无法凑成返回 <code>-1</code>。</p>
</blockquote>
</li>
<li><p><strong>188. 买卖股票的最佳时机 IV</strong></p>
<blockquote>
<p>给定股票价格数组 <code>prices</code> 和整数 <code>k</code>，最多进行 <code>k</code> 次交易，返回最大利润。</p>
</blockquote>
</li>
<li><p><strong>309. 最佳买卖股票时机含冷冻期</strong></p>
<blockquote>
<p>给定股票价格数组 <code>prices</code>，可多次交易，但卖出后第二天为冷冻期不能买入，返回最大利润。</p>
</blockquote>
</li>
<li><p><strong>714. 买卖股票的最佳时机含手续费</strong></p>
<blockquote>
<p>给定股票价格数组 <code>prices</code> 和手续费 <code>fee</code>，可多次交易，每次卖出需支付手续费，返回最大利润。</p>
</blockquote>
</li>
<li><p><strong>1035. 不相交的线</strong></p>
<blockquote>
<p>给定两个整数数组 <code>nums1</code> 和 <code>nums2</code>，在不相交的前提下连接相等数字，返回可画的最大连线数。</p>
</blockquote>
</li>
<li><p><strong>392. 判断子序列</strong></p>
<blockquote>
<p>给定字符串 <code>s</code> 和 <code>t</code>，判断 <code>s</code> 是否为 <code>t</code> 的子序列。</p>
</blockquote>
</li>
<li><p><strong>115. 不同的子序列</strong></p>
<blockquote>
<p>给定字符串 <code>s</code> 和 <code>t</code>，返回 <code>s</code> 的子序列中等于 <code>t</code> 的不同子序列个数。</p>
</blockquote>
</li>
<li><p><strong>583. 两个字符串的删除操作</strong></p>
<blockquote>
<p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，每次可删除任意一个字符串中的一个字符，返回使两字符串相同所需的最少删除次数。</p>
</blockquote>
</li>
<li><p><strong>72. 编辑距离</strong></p>
<blockquote>
<p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，返回将 <code>word1</code> 转换为 <code>word2</code> 所需的最少操作数（插入、删除、替换）。</p>
</blockquote>
</li>
<li><p><strong>647. 回文子串</strong></p>
<blockquote>
<p>给定字符串 <code>s</code>，返回 <code>s</code> 中回文子串的数量。</p>
</blockquote>
</li>
<li><p><strong>516. 最长回文子序列</strong></p>
<blockquote>
<p>给定字符串 <code>s</code>，返回 <code>s</code> 的最长回文子序列长度。</p>
</blockquote>
</li>
</ul>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><ul>
<li><p><strong>300. 最长递增子序列</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code>，返回最长严格递增子序列的长度。</p>
</blockquote>
</li>
<li><p><strong>674. 最长连续递增序列</strong></p>
<blockquote>
<p>给定整数数组 <code>nums</code>，返回最长连续严格递增子序列的长度。</p>
</blockquote>
</li>
<li><p><strong>718. 最长重复子数组</strong></p>
<blockquote>
<p>给定两个整数数组 <code>nums1</code> 和 <code>nums2</code>，返回两个数组中公共的、长度最长的连续子数组长度。</p>
</blockquote>
</li>
<li><p><strong>1143. 最长公共子序列</strong></p>
<blockquote>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回它们的最长公共子序列长度。</p>
</blockquote>
</li>
<li><p><strong>739. 每日温度</strong></p>
<blockquote>
<p>给定整数数组 <code>temperatures</code>，返回一个数组 <code>answer</code>，其中 <code>answer[i]</code> 表示从第 <code>i</code> 天起需要等多少天才会有更高的温度；若之后都不会升温则为 <code>0</code>。</p>
</blockquote>
</li>
<li><p><strong>496. 下一个更大元素 I</strong></p>
<blockquote>
<p>给定两个没有重复元素的数组 <code>nums1</code> 和 <code>nums2</code>（<code>nums1</code> 是 <code>nums2</code> 的子集），对 <code>nums1</code> 中每个元素，找出其在 <code>nums2</code> 中对应位置右侧第一个比它大的元素；不存在则为 <code>-1</code>。</p>
</blockquote>
</li>
<li><p><strong>503. 下一个更大元素 II</strong></p>
<blockquote>
<p>给定一个循环数组 <code>nums</code>，返回每个元素的下一个更大元素；若不存在则为 <code>-1</code>。</p>
</blockquote>
</li>
<li><p><strong>42. 接雨水</strong></p>
<blockquote>
<p>给定非负整数数组 <code>height</code> 表示柱状图高度，计算按此排列能接到的雨水总量。</p>
</blockquote>
</li>
<li><p><strong>84. 柱状图中最大的矩形</strong></p>
<blockquote>
<p>给定非负整数数组 <code>heights</code> 表示柱状图每个柱子的高度，返回能够勾勒出的最大矩形面积。</p>
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yangzhb-cn.github.io">杨志彬</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yangzhb-cn.github.io/2026/01/17/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%B7%AF/">https://yangzhb-cn.github.io/2026/01/17/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%B7%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yangzhb-cn.github.io" target="_blank">在秩序中远行</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/2153815987697221632.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/18/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" title="项目部署"><img class="cover" src="/img/2153815987697221632.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">项目部署</div></div><div class="info-2"><div class="info-item-1">多环境 SpringBoot项目,通过application.yml添加不同的后缀来区分配置文件 数据库地址 缓存地址 消息队列地址 项目端口号 服务器配置   可以在启动项目时传入环境变量:  1java -jar ./&lt;name&gt;.jar --spring.profiles.active=pred  项目部署原生部署前端部署 黑马点评作为参考   安装目标软件或者直接本地上传  12curl -o 压缩包重命名 对应的网站资源tar -zxvf 压缩包重命名  现在的前端项目可以打包成dist然后上传 需要web服务器:nginx、apache、tomcat 注意nginx权限     12345ps -ef | grep nginx #查看开启nginx服务的用户，最好是root# 如果不是查看nginx 的配置文件第一行# user nobody; 可能默认就是nobody 改为root即可user root;  nginx -t 检查配置 将前端项目移动到 /opt/homebrew/Cellar/nginx/1.29.4/html/hmdp  后面配置ng...</div></div></div></a><a class="pagination-related" href="/2026/01/15/%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4-%E8%87%AA%E6%9F%A5/" title="常用终端命令(自查)"><img class="cover" src="/img/2611933635770580992.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">常用终端命令(自查)</div></div><div class="info-2"><div class="info-item-1">Linux命令符号&gt;  &gt;&gt;  | &amp; FD &gt; 把标准输出（stdout）重定向到文件，覆盖写入（文件不存在则创建） &gt;&gt;把标准输出追加到文件末尾，不覆盖  1234567# 这里 cmd 为某个命令的输出# 覆盖cmd &gt; out.log# 追加cmd &gt;&gt; out.log# 把标准错误（文件描述符 2）重定向到标准输出（文件描述符 1）当前指向的位置，常用于把错误和正常输出写到同一个地方2&gt;&amp;1  |把左边命令的输出作为右边命令的输入，用于把多个命令串起来处理数据流  12# 在进程列表中筛选javaps -ef | grep java  &amp;把命令放到后台运行，终端不会被该命令阻塞，你可以继续输入其他命令 &amp;放在重定向里（如 2&gt;&amp;1）表示“后面跟的是文件描述符FD”，用于把一个 FD 重定向到另一个 FD  12# 把标准输出(1)写入 out.log，再把标准错误(2)合并到标准输出的去向，并在后台运行cmd &gt; out.log 2&gt;&amp;1 &am...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/2244933495988158464.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">杨志彬</div><div class="author-info-description">在约束中演进</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yangzhb-cn"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yangzhb-cn" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yangzhb_cn@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">未完待续...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">3.</span> <span class="toc-text">哈希</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">栈和队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">7.</span> <span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">8.</span> <span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">9.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">10.</span> <span class="toc-text">单调栈</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/18/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" title="项目部署"><img src="/img/2153815987697221632.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目部署"/></a><div class="content"><a class="title" href="/2026/01/18/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" title="项目部署">项目部署</a><time datetime="2026-01-17T18:31:19.000Z" title="发表于 2026-01-18 02:31:19">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/17/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%B7%AF/" title="经典算法面试题思路"><img src="/img/2153815987697221632.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="经典算法面试题思路"/></a><div class="content"><a class="title" href="/2026/01/17/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%B7%AF/" title="经典算法面试题思路">经典算法面试题思路</a><time datetime="2026-01-17T09:21:57.000Z" title="发表于 2026-01-17 17:21:57">2026-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/15/%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4-%E8%87%AA%E6%9F%A5/" title="常用终端命令(自查)"><img src="/img/2611933635770580992.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用终端命令(自查)"/></a><div class="content"><a class="title" href="/2026/01/15/%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4-%E8%87%AA%E6%9F%A5/" title="常用终端命令(自查)">常用终端命令(自查)</a><time datetime="2026-01-15T14:43:20.000Z" title="发表于 2026-01-15 22:43:20">2026-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/14/%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" title="算法理解"><img src="/img/2153815987697221632.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法理解"/></a><div class="content"><a class="title" href="/2026/01/14/%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" title="算法理解">算法理解</a><time datetime="2026-01-14T09:21:57.000Z" title="发表于 2026-01-14 17:21:57">2026-01-14</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 杨志彬</span></div><div class="footer_custom_text">欢迎登船，航程已在途中</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4-b1"></script></div></div></body></html>
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法理解</title>
      <link href="/2026/01/14/%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"/>
      <url>/2026/01/14/%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法："><a href="#排序算法：" class="headerlink" title="排序算法："></a>排序算法：</h1><ul><li><strong>选择排序</strong>：假设<code>[0,i)</code>已经排序好了，找到<code>[i,n)</code>最小数m，m和i交换。最多需要交换n-1次，最后一个自动最大</li><li><strong>冒泡排序</strong>：相邻之间互相交换，小的在前面，大的再后面，最终实现最大的在最后面，达到冒泡效果。此时继续对<code>[0,n-1)</code>操作</li><li><strong>插入排序</strong>：假设<code>[0,i)</code>已经排序好了，将i插入到要<code>[0,i)</code>里面，只需要给它挪一挪即可</li><li><strong>快速排序</strong>：<ul><li>先选择一个基点0，然后从1开始从左往右找第一个比<code>c[0]</code>大的数。同时从n-1开始从右往左找第一个比<code>c[0]</code>小的数，找到以后，这两个数进行交换。然后继续找第二个，直到左指针右指针<code>i=j</code>重合。此时交换0和重合位置i (哨兵)。最终实现i的左边的数 &lt;&#x3D; <code>c[i]</code> &lt;&#x3D; i的右边的数</li><li>获得这个哨兵，然后分别递归<code>[0,i)</code>,<code>[i+1,n)</code>即可</li></ul></li><li><strong>归并排序</strong>：<ul><li>递：不断对区间一分为二</li><li>归：用新数组整理最小的区间对应的顺序，一步步向上归<ul><li>采用后序遍历方式，先求出中点，然后递归左边，递归右边，最后合并</li><li>合并：构建一个临时数组，按顺序放目标数组（递完以后的子数组）的数字，然后复制到目标数组的位置上面去</li><li>这样子一步步从小到大进行重排</li></ul></li></ul></li><li><strong>堆排序</strong>：<ul><li><p>堆：完全二叉树结构 + 任意节点的值<code>&lt;=(&gt;=)</code>其子节点的值被称为小顶堆(大顶堆)</p><ul><li>完全二叉树仅允许最底层的节点不完全填满，且最底层的节点必须从左至右依次连续填充</li><li>小顶堆大顶堆的区别只是堆化操作时的比较交换不同</li><li>这里的堆由数组实现<ul><li>当使用数组表示二叉树时,元素代表节点值,索引代表节点在二叉树中的位置。节点指针通过索引映射公式来实现。给定索引i,其左子节点的索引为<code>2i+1</code>,右子节点的索引为<code>2i+2</code>,父节点的索引为<code>(i-1)/2</code>(向下整除)。当索引越界时,表示空节点或节点不存在。</li></ul></li></ul></li><li><p>堆的基础知识：</p><ul><li>节点入堆出堆操作<ul><li>入堆（自底向上）：首先加到末尾点，找到父节点，比较交换。以此类推直到交换到根节点。时间复杂度为<code>O(log n)</code></li><li>出堆（自顶向下）：这里出堆是出根节点。那就交换根节点和尾节点，然后删除交换后的尾节点。然后对根节点进行自顶向下的堆化操作来保持堆结构。目标是找到最小数，然后挪到堆顶。那么就从根节点开始，比较该节点和它的左右子节点的值，看看哪一个最小，把最小的和当前节点进行交换。然后向下遍历即可。时间复杂度为<code>O(log n)</code></li></ul></li><li>小顶堆构建方式1：建立空堆后一个个入堆<code>O(log n)</code>，节点从顶到底依次被添加。时间复杂度为<code>O(nlog n)</code></li><li>小顶堆构建方式2：将列表原封不动添加到二叉树中O(n)，倒序遍历节点<code>for (int i = parent(size() - 1); i &gt;= 0; i--) </code>，然后一个个执行自顶向下的堆化操作，此时不用管叶节点，<strong>时间复杂度降低至O(n)</strong><ul><li>为了降低计算难度,假没给定一个节点数量为n、高度为h的”完美二叉树”,该假设不会影响计算结果的正确性</li><li>高度为$h-k$那一行的节点交换次数为$2^{h-k}(h-k)$，其中$2^{h-k}$是该行节点数目，$h-k$是交换次数<br>   $$T(h)&#x3D;2^0h+2^1(h-1)+2^2(h-2)+…+2^{h-1} &#x3D; O(2^h) &#x3D; O(n)$$</li></ul></li></ul></li><li><p>堆排序的不同做法</p><ul><li>在原数组堆化操作，采取小顶堆构建方式2<ul><li>堆化以后，一个个出堆，<strong>需要额外数组保存出堆结果</strong></li></ul></li><li>直接在这个数组操作并返回这个小顶堆：先建立大顶堆O(n)，然后将堆顶和尾节点交换<code>for (int i = nums.length - 1; i &gt; 0; i--)</code> ，然后删除这个尾节点（逻辑删除），然后堆顶进行自顶而下的堆化操作。本质就是出堆操作，时间复杂度为<code>n O(log n)</code>。</li></ul></li></ul></li><li><strong>桶排序</strong><ul><li>设置一些具有大小顺序的桶,每个桶对应一个数据范围,将数据平均分配到各个桶中;然后,在每个桶内部分别执行排序;最终按照桶的顺序将所有数据合并。<ul><li>初始化k个桶,将n个元素分配到k个桶中。<ul><li>这一步是关键：将数组的值nums[i]映射到桶的索引</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Float&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) (num * k);</span><br><span class="line"><span class="comment">// 将 num 添加进桶 i</span></span><br><span class="line">buckets.get(i).add(num);</span><br></pre></td></tr></table></figure></li><li>对每个桶分别执行排序(这里采用编程语言的内置排序函数)。</li><li>按照桶从小到大的顺序遍历合并结果。</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2026/01/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2026/01/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>dd</p><p>内容<br>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><hr><hr><hr><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><hr><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2026/01/11/hello-world/"/>
      <url>/2026/01/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

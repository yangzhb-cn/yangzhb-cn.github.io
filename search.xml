<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>经典算法面试题思路</title>
      <link href="/2026/01/15/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
      <url>/2026/01/15/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li><p><strong>704. 二分查找</strong></p><blockquote><p>给定一个按升序排列的整数数组 <code>nums</code> 和目标值 <code>target</code>，在数组中查找 <code>target</code>，若存在返回其索引，否则返回 <code>-1</code>。</p></blockquote></li><li><p><strong>34. 在排序数组中查找元素的第一个和最后一个位置</strong></p><blockquote><p>给定一个按升序排列的整数数组 <code>nums</code> 和目标值 <code>target</code>，返回 <code>target</code> 在数组中的起始位置和结束位置；若不存在返回 <code>[-1, -1]</code>。</p></blockquote></li><li><p><strong>27. 移除元素</strong></p><blockquote><p>给定数组 <code>nums</code> 和值 <code>val</code>，原地移除所有等于 <code>val</code> 的元素，并返回移除后数组的新长度（元素顺序可改变）。</p></blockquote></li><li><p><strong>88. 合并两个有序数组</strong></p><blockquote><p>给定两个按非递减顺序排列的数组 <code>nums1</code> 和 <code>nums2</code>（其中 <code>nums1</code> 预留空间），将 <code>nums2</code> 合并到 <code>nums1</code> 中，使合并后仍为非递减顺序。</p></blockquote></li><li><p><strong>977. 有序数组的平方</strong></p><blockquote><p>给定一个按非递减顺序排列的整数数组 <code>nums</code>，返回每个元素平方后的数组，并按非递减顺序排列。</p></blockquote></li><li><p><strong>209. 长度最小的子数组</strong></p><blockquote><p>给定正整数数组 <code>nums</code> 和正整数 <code>target</code>，找出和大于等于 <code>target</code> 的长度最小的连续子数组并返回其长度；若不存在返回 <code>0</code>。</p></blockquote></li><li><p><strong>3. 无重复字符的最长子串</strong></p><blockquote><p>给定字符串 <code>s</code>，找出不含重复字符的最长子串长度。</p></blockquote></li><li><p><strong>713. 乘积小于 K 的子数组</strong></p><blockquote><p>给定正整数数组 <code>nums</code> 和整数 <code>k</code>，返回乘积严格小于 <code>k</code> 的连续子数组的个数。</p></blockquote></li><li><p><strong>59. 螺旋矩阵 II</strong></p><blockquote><p>给定正整数 <code>n</code>，生成一个 <code>n x n</code> 矩阵，按顺时针螺旋顺序填入从 <code>1</code> 到 <code>n^2</code> 的整数。</p></blockquote></li></ul><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li><p><strong>203. 移除链表元素</strong></p><blockquote><p>给定一个链表的头节点 <code>head</code> 和一个整数 <code>val</code>，删除链表中所有节点值等于 <code>val</code> 的节点，并返回新的头节点。</p></blockquote></li><li><p><strong>707. 设计链表</strong></p><blockquote><p>设计并实现链表结构，支持获取指定索引节点值、在头部&#x2F;尾部&#x2F;指定位置插入节点、删除指定位置节点等操作。</p></blockquote></li><li><p><strong>206. 反转链表</strong></p><blockquote><p>给定单链表的头节点 <code>head</code>，将链表反转，并返回反转后的头节点。</p></blockquote></li><li><p><strong>92. 反转链表 II</strong></p><blockquote><p>给定单链表头节点 <code>head</code> 和两个整数 <code>left</code>、<code>right</code>，将链表中从位置 <code>left</code> 到位置 <code>right</code> 的节点进行反转，并返回反转后的链表。</p></blockquote></li><li><p><strong>25. K 个一组反转链表</strong></p><blockquote><p>给定链表头节点 <code>head</code> 和整数 <code>k</code>，每 <code>k</code> 个节点一组进行反转，返回反转后的链表；不足 <code>k</code> 个的部分保持原顺序。</p></blockquote></li><li><p><strong>24. 两两交换链表中的节点</strong></p><blockquote><p>给定链表头节点 <code>head</code>，两两交换相邻节点并返回交换后的链表（不能只修改节点值，需实际交换节点）。</p></blockquote></li><li><p><strong>19. 删除链表的倒数第 N 个节点</strong></p><blockquote><p>给定链表头节点 <code>head</code> 和整数 <code>n</code>，删除链表的倒数第 <code>n</code> 个节点，并返回新的头节点。</p></blockquote></li><li><p><strong>237. 删除链表中的节点</strong></p><blockquote><p>给定需要被删除的节点 <code>node</code>（不是头节点），在无法访问头节点的情况下删除该节点。</p></blockquote></li><li><p><strong>82. 删除排序链表中的重复元素 II</strong></p><blockquote><p>给定一个已排序的链表头节点 <code>head</code>，删除所有出现重复的节点（重复值的节点全部移除），只保留不重复的节点，返回新的头节点。</p></blockquote></li><li><p><strong>面试题 02.07. 链表相交</strong></p><blockquote><p>给定两个单链表的头节点 <code>headA</code> 和 <code>headB</code>，判断两链表是否相交；若相交返回第一个相交节点，否则返回 <code>null</code>。</p></blockquote></li><li><p><strong>141. 环形链表</strong></p><blockquote><p>给定链表头节点 <code>head</code>，判断链表中是否存在环，存在返回 <code>true</code>，否则返回 <code>false</code>。</p></blockquote></li><li><p><strong>142. 环形链表 II</strong></p><blockquote><p>给定链表头节点 <code>head</code>，若链表存在环，返回环的入口节点；若不存在环，返回 <code>null</code>。</p></blockquote></li><li><p><strong>143. 重排链表</strong></p><blockquote><p>给定链表头节点 <code>head</code>，将链表重排为 <code>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...</code>，并要求原地完成。</p></blockquote></li></ul><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><ul><li><p><strong>242. 有效的字母异位词</strong></p><blockquote><p>给定两个字符串 <code>s</code> 和 <code>t</code>，判断 <code>t</code> 是否是 <code>s</code> 的字母异位词（包含相同字符且各字符出现次数相同）。</p></blockquote></li><li><p><strong>349. 两个数组的交集</strong></p><blockquote><p>给定两个整数数组 <code>nums1</code> 和 <code>nums2</code>，返回它们的交集（结果中的每个元素必须唯一）。</p></blockquote></li><li><p><strong>202. 快乐数</strong></p><blockquote><p>给定一个整数 <code>n</code>，反复将其替换为各位数字平方和；如果最终变为 <code>1</code> 则为快乐数，否则会进入循环不是快乐数。</p></blockquote></li><li><p><strong>1. 两数之和</strong></p><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>target</code>，返回两个下标，使得它们对应的数字之和等于 <code>target</code>（假设恰好有一个解，且同一元素不能重复使用）。</p></blockquote></li><li><p><strong>454. 四数相加 II</strong></p><blockquote><p>给定四个整数数组 <code>nums1、nums2、nums3、nums4</code>，计算有多少个元组 <code>(i,j,k,l)</code> 使得 <code>nums1[i] + nums2[j] + nums4[l] + nums3[k] == 0</code>。</p></blockquote></li><li><p><strong>383. 赎金信</strong></p><blockquote><p>给定字符串 <code>ransomNote</code> 和 <code>magazine</code>，判断 <code>ransomNote</code> 能否由 <code>magazine</code> 中的字符构成（每个字符只能使用一次）。</p></blockquote></li><li><p><strong>15. 三数之和</strong></p><blockquote><p>给定整数数组 <code>nums</code>，返回所有不重复的三元组 <code>[nums[i], nums[j], nums[k]]</code>，使其和为 <code>0</code>。</p></blockquote></li><li><p><strong>18. 四数之和</strong></p><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>target</code>，返回所有不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code>，使其和等于 <code>target</code>。</p></blockquote></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul><li><p><strong>344. 反转字符串</strong></p><blockquote><p>给定一个字符数组 <code>s</code>，将其原地反转。</p></blockquote></li><li><p><strong>541. 反转字符串 II</strong></p><blockquote><p>给定字符串 <code>s</code> 和整数 <code>k</code>，每计数到 <code>2k</code> 个字符，就反转前 <code>k</code> 个字符；如果剩余少于 <code>k</code> 个则全部反转，介于 <code>k</code> 和 <code>2k</code> 之间则反转前 <code>k</code> 个。</p></blockquote></li><li><p><strong>剑指 Offer 05. 替换空格</strong></p><blockquote><p>给定字符串 <code>s</code>，把字符串中的每个空格替换成 <code>&quot;%20&quot;</code>，返回替换后的字符串。</p></blockquote></li><li><p><strong>剑指 Offer 58-II. 左旋转字符串</strong></p><blockquote><p>给定字符串 <code>s</code> 和整数 <code>n</code>，将字符串左旋转 <code>n</code> 位（把前 <code>n</code> 个字符移动到字符串末尾）。</p></blockquote></li></ul><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><ul><li><p><strong>28. 实现 strStr()</strong></p><blockquote><p>给定两个字符串 <code>haystack</code> 和 <code>needle</code>，在 <code>haystack</code> 中找出 <code>needle</code> 第一次出现的下标；若不存在返回 <code>-1</code>（当 <code>needle</code> 为空时返回 <code>0</code>）。</p></blockquote></li><li><p><strong>459. 重复的子字符串</strong></p><blockquote><p>给定非空字符串 <code>s</code>，判断它是否可以由它的某个子串重复多次构成。</p></blockquote></li><li><p><strong>232. 用栈实现队列</strong></p><blockquote><p>仅使用两个栈实现一个队列，支持 <code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code> 等操作。</p></blockquote></li><li><p><strong>225. 用队列实现栈</strong></p><blockquote><p>仅使用队列实现一个栈，支持 <code>push</code>、<code>pop</code>、<code>top</code>、<code>empty</code> 等操作。</p></blockquote></li><li><p><strong>20. 有效的括号</strong></p><blockquote><p>给定只包含 <code>&#39;(&#39;、&#39;)&#39;、&#39;{&#39;、&#39;}&#39;、&#39;[&#39;、&#39;]&#39;</code> 的字符串 <code>s</code>，判断括号是否有效（需正确闭合且顺序正确）。</p></blockquote></li><li><p><strong>1047. 删除字符串中的所有相邻重复项</strong></p><blockquote><p>给定字符串 <code>s</code>，反复删除相邻且相同的字符对，直到无法继续删除，返回最终字符串。</p></blockquote></li><li><p><strong>150. 逆波兰表达式求值</strong></p><blockquote><p>给定一个表示逆波兰表达式的字符串数组 <code>tokens</code>，计算表达式的值（运算符包含 <code>+ - * /</code>）。</p></blockquote></li><li><p><strong>239. 滑动窗口最大值</strong></p><blockquote><p>给定整数数组 <code>nums</code> 和窗口大小 <code>k</code>，返回每个滑动窗口中的最大值组成的数组。</p></blockquote></li><li><p><strong>347. 前 K 个高频元素</strong></p><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，返回出现频率前 <code>k</code> 高的元素（返回顺序不限）。</p></blockquote></li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul><li><p><strong>144. 二叉树的前序遍历</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，返回其节点值的前序遍历结果（根-左-右）。</p></blockquote></li><li><p><strong>94. 二叉树的中序遍历</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，返回其节点值的中序遍历结果（左-根-右）。</p></blockquote></li><li><p><strong>145. 二叉树的后序遍历</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，返回其节点值的后序遍历结果（左-右-根）。</p></blockquote></li><li><p><strong>102. 二叉树的层序遍历</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，按层返回节点值的遍历结果。</p></blockquote></li><li><p><strong>226. 翻转二叉树</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，翻转这棵二叉树，并返回其根节点。</p></blockquote></li><li><p><strong>100. 相同的树</strong></p><blockquote><p>给定两棵二叉树的根节点 <code>p</code> 和 <code>q</code>，判断它们是否在结构和节点值上完全相同。</p></blockquote></li><li><p><strong>101. 对称二叉树</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，判断它是否是轴对称的。</p></blockquote></li><li><p><strong>104. 二叉树的最大深度</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，返回其最大深度（从根到最远叶子节点的节点数）。</p></blockquote></li><li><p><strong>111. 二叉树的最小深度</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，返回其最小深度（从根到最近叶子节点的最短路径节点数）。</p></blockquote></li><li><p><strong>222. 完全二叉树的节点个数</strong></p><blockquote><p>给定一棵完全二叉树的根节点 <code>root</code>，返回该树的节点个数。</p></blockquote></li><li><p><strong>110. 平衡二叉树</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，判断该树是否为平衡二叉树（任意节点左右子树高度差不超过 1）。</p></blockquote></li><li><p><strong>257. 二叉树的所有路径</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，返回从根节点到所有叶子节点的路径字符串列表。</p></blockquote></li><li><p><strong>404. 左叶子之和</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，返回所有左叶子节点值之和。</p></blockquote></li><li><p><strong>513. 找树左下角的值</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code>，返回树最底层最左边节点的值。</p></blockquote></li><li><p><strong>112. 路径总和</strong></p><blockquote><p>给定二叉树的根节点 <code>root</code> 和目标和 <code>targetSum</code>，判断是否存在从根到叶子节点的路径，使路径上节点值之和等于 <code>targetSum</code>。</p></blockquote></li><li><p><strong>106. 从中序与后序遍历序列构造二叉树</strong></p><blockquote><p>给定二叉树的中序遍历数组 <code>inorder</code> 和后序遍历数组 <code>postorder</code>，构造并返回该二叉树。</p></blockquote></li><li><p><strong>654. 最大二叉树</strong></p><blockquote><p>给定不含重复元素的整数数组 <code>nums</code>，按“最大值为根、左侧构建左子树、右侧构建右子树”的规则构造并返回最大二叉树。</p></blockquote></li><li><p><strong>617. 合并二叉树</strong></p><blockquote><p>给定两棵二叉树的根节点 <code>root1</code> 和 <code>root2</code>，将两棵树合并成一棵新树：重叠节点值相加，非重叠节点直接使用原节点。</p></blockquote></li><li><p><strong>700. 二叉搜索树中的搜索</strong></p><blockquote><p>给定二叉搜索树根节点 <code>root</code> 和值 <code>val</code>，在 BST 中查找值为 <code>val</code> 的节点并返回其子树根节点；若不存在返回 <code>null</code>。</p></blockquote></li><li><p><strong>98. 验证二叉搜索树</strong></p><blockquote><p>给定二叉树根节点 <code>root</code>，判断其是否为有效的二叉搜索树。</p></blockquote></li><li><p><strong>530. 二叉搜索树的最小绝对差</strong></p><blockquote><p>给定二叉搜索树根节点 <code>root</code>，返回任意两节点值之间的最小绝对差。</p></blockquote></li><li><p><strong>501. 二叉搜索树中的众数</strong></p><blockquote><p>给定二叉搜索树根节点 <code>root</code>，返回所有出现频率最高的元素（众数）。</p></blockquote></li><li><p><strong>236. 二叉树的最近公共祖先</strong></p><blockquote><p>给定二叉树根节点 <code>root</code> 和两个节点 <code>p</code>、<code>q</code>，返回它们的最近公共祖先节点。</p></blockquote></li><li><p><strong>235. 二叉搜索树的最近公共祖先</strong></p><blockquote><p>给定二叉搜索树根节点 <code>root</code> 和两个节点 <code>p</code>、<code>q</code>，返回它们的最近公共祖先节点。</p></blockquote></li><li><p><strong>701. 二叉搜索树中的插入操作</strong></p><blockquote><p>给定二叉搜索树根节点 <code>root</code> 和要插入的值 <code>val</code>，将 <code>val</code> 插入 BST 并返回插入后的根节点。</p></blockquote></li><li><p><strong>450. 删除二叉搜索树中的节点</strong></p><blockquote><p>给定二叉搜索树根节点 <code>root</code> 和键值 <code>key</code>，删除 BST 中值等于 <code>key</code> 的节点，并返回新的根节点。</p></blockquote></li><li><p><strong>669. 修剪二叉搜索树</strong></p><blockquote><p>给定二叉搜索树根节点 <code>root</code> 和边界 <code>low</code>、<code>high</code>，修剪树使所有节点值都在 <code>[low, high]</code> 范围内，返回修剪后的根节点。</p></blockquote></li><li><p><strong>108. 将有序数组转换为二叉搜索树</strong></p><blockquote><p>给定一个按升序排列的整数数组 <code>nums</code>，将其转换为一棵高度平衡的二叉搜索树并返回根节点。</p></blockquote></li><li><p><strong>538. 把二叉搜索树转换为累加树</strong></p><blockquote><p>给定二叉搜索树根节点 <code>root</code>，将其转换为累加树，使每个节点的值变为原值加上所有大于它的节点值之和。</p></blockquote></li></ul><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul><li><p><strong>77. 组合</strong></p><blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p></blockquote></li><li><p><strong>216. 组合总和 III</strong></p><blockquote><p>找出所有由 <code>1</code> 到 <code>9</code> 中 <code>k</code> 个不同数字组成、且数字和为 <code>n</code> 的组合（每个数字最多使用一次）。</p></blockquote></li><li><p><strong>17. 电话号码的字母组合</strong></p><blockquote><p>给定仅包含数字 <code>2-9</code> 的字符串 <code>digits</code>，返回它能表示的所有可能的字母组合。</p></blockquote></li><li><p><strong>39. 组合总和</strong></p><blockquote><p>给定一个无重复元素数组 <code>candidates</code> 和目标值 <code>target</code>，返回所有和为 <code>target</code> 的组合（同一数字可无限次使用）。</p></blockquote></li><li><p><strong>40. 组合总和 II</strong></p><blockquote><p>给定一个可能包含重复元素的数组 <code>candidates</code> 和目标值 <code>target</code>，返回所有和为 <code>target</code> 的组合（每个数字最多使用一次，结果不能重复）。</p></blockquote></li><li><p><strong>131. 分割回文串</strong></p><blockquote><p>给定字符串 <code>s</code>，将 <code>s</code> 分割成若干子串，使每个子串都是回文串，返回所有可能的分割方案。</p></blockquote></li><li><p><strong>93. 复原 IP 地址</strong></p><blockquote><p>给定只包含数字的字符串 <code>s</code>，返回所有可能的有效 IP 地址组合（需要插入三个点）。</p></blockquote></li><li><p><strong>78. 子集</strong></p><blockquote><p>给定一个不含重复元素的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</p></blockquote></li><li><p><strong>90. 子集 II</strong></p><blockquote><p>给定一个可能包含重复元素的整数数组 <code>nums</code>，返回所有可能的子集（不能包含重复子集）。</p></blockquote></li><li><p><strong>491. 递增子序列</strong></p><blockquote><p>给定整数数组 <code>nums</code>，返回所有不同的递增子序列（长度至少为 2，允许相等即非递减）。</p></blockquote></li><li><p><strong>46. 全排列</strong></p><blockquote><p>给定一个不含重复元素的整数数组 <code>nums</code>，返回其所有可能的全排列。</p></blockquote></li><li><p><strong>47. 全排列 II</strong></p><blockquote><p>给定一个可能包含重复元素的整数数组 <code>nums</code>，返回所有不重复的全排列。</p></blockquote></li><li><p><strong>51. N 皇后</strong></p><blockquote><p>给定整数 <code>n</code>，返回所有不同的 <code>n</code> 皇后问题的解决方案（在 <code>n×n</code> 棋盘上放置 <code>n</code> 个皇后且互不攻击）。</p></blockquote></li><li><p><strong>37. 解数独</strong></p><blockquote><p>编写程序填充 <code>9×9</code> 的数独，使其满足数独规则（每行、每列、每个 <code>3×3</code> 宫内数字 <code>1-9</code> 不重复）。</p></blockquote></li></ul><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><ul><li><p><strong>455. 分发饼干</strong></p><blockquote><p>给定孩子的胃口值数组 <code>g</code> 和饼干尺寸数组 <code>s</code>，每个孩子最多分到一块饼干，若饼干尺寸不小于胃口则孩子满足；返回最多能满足的孩子数量。</p></blockquote></li><li><p><strong>376. 摆动序列</strong></p><blockquote><p>给定整数数组 <code>nums</code>，返回最长摆动子序列的长度（相邻差值正负交替）。</p></blockquote></li><li><p><strong>53. 最大子序和</strong></p><blockquote><p>给定整数数组 <code>nums</code>，找出具有最大和的连续子数组，并返回该最大和。</p></blockquote></li><li><p><strong>122. 买卖股票的最佳时机 II</strong></p><blockquote><p>给定股票价格数组 <code>prices</code>，可进行多次交易（同一时间只能持有一股），返回可获得的最大利润。</p></blockquote></li><li><p><strong>55. 跳跃游戏</strong></p><blockquote><p>给定非负整数数组 <code>nums</code>，<code>nums[i]</code> 表示从位置 <code>i</code> 最远可跳跃的步数，判断是否能到达最后一个下标。</p></blockquote></li><li><p><strong>45. 跳跃游戏 II</strong></p><blockquote><p>给定非负整数数组 <code>nums</code>，<code>nums[i]</code> 表示从位置 <code>i</code> 最远可跳跃的步数，返回到达最后一个下标的最少跳跃次数。</p></blockquote></li><li><p><strong>1005. K 次取反后最大化的数组和</strong></p><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，每次可选择一个元素取反，最多进行 <code>k</code> 次操作，返回数组元素和的最大值。</p></blockquote></li><li><p><strong>134. 加油站</strong></p><blockquote><p>给定两个数组 <code>gas</code> 和 <code>cost</code>，<code>gas[i]</code> 为第 <code>i</code> 个加油站油量，<code>cost[i]</code> 为从 <code>i</code> 到 <code>i+1</code> 消耗；若能绕行一周返回起始站下标，否则返回 <code>-1</code>。</p></blockquote></li><li><p><strong>135. 分发糖果</strong></p><blockquote><p>给定数组 <code>ratings</code> 表示孩子评分，需给每个孩子至少 1 颗糖，且评分更高的孩子比相邻孩子糖更多；返回需要的最少糖果数。</p></blockquote></li><li><p><strong>860. 柠檬水找零</strong></p><blockquote><p>在柠檬水售价 5 元的情况下，按顾客付款顺序（5&#x2F;10&#x2F;20）找零，判断能否对每位顾客正确找零。</p></blockquote></li><li><p><strong>406. 根据身高重建队列</strong></p><blockquote><p>给定数组 <code>people</code>，每个元素为 <code>[h, k]</code> 表示身高 <code>h</code>、前面身高 ≥ <code>h</code> 的人数为 <code>k</code>，重建并返回队列。</p></blockquote></li><li><p><strong>452. 用最少数量的箭引爆气球</strong></p><blockquote><p>给定二维数组 <code>points</code> 表示气球直径区间 <code>[xstart, xend]</code>，一支箭在 <code>x</code> 位置可引爆所有包含 <code>x</code> 的气球，返回引爆所有气球的最少箭数。</p></blockquote></li><li><p><strong>435. 无重叠区间</strong></p><blockquote><p>给定区间数组 <code>intervals</code>，移除最少数量的区间，使剩余区间互不重叠，返回需要移除的数量。</p></blockquote></li><li><p><strong>763. 划分字母区间</strong></p><blockquote><p>给定字符串 <code>s</code>，将其划分为尽可能多的片段，使每个字母最多出现在一个片段中，返回每个片段的长度列表。</p></blockquote></li><li><p><strong>56. 合并区间</strong></p><blockquote><p>给定区间数组 <code>intervals</code>，合并所有重叠区间并返回合并后的区间数组。</p></blockquote></li><li><p><strong>738. 单调递增的数字</strong></p><blockquote><p>给定整数 <code>n</code>，返回小于等于 <code>n</code> 的最大整数，使其各位数字满足单调递增（从左到右非递减）。</p></blockquote></li><li><p><strong>968. 监控二叉树</strong></p><blockquote><p>给定二叉树根节点 <code>root</code>，在树上放置最少的摄像头，使每个节点都被监控（摄像头可监控自身、父节点和子节点）。</p></blockquote></li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><p><strong>509. 斐波那契数</strong></p><blockquote><p>给定整数 <code>n</code>，返回第 <code>n</code> 个斐波那契数。</p></blockquote></li><li><p><strong>70. 爬楼梯</strong></p><blockquote><p>给定整数 <code>n</code>，每次可爬 1 或 2 阶，返回爬到第 <code>n</code> 阶的不同方法数。</p></blockquote></li><li><p><strong>746. 使用最小花费爬楼梯</strong></p><blockquote><p>给定数组 <code>cost</code>，<code>cost[i]</code> 为踏上第 <code>i</code> 阶的花费，可从 0 或 1 开始，每次走 1 或 2 阶，返回到达楼顶的最小花费。</p></blockquote></li><li><p><strong>1049. 最后一块石头的重量 II</strong></p><blockquote><p>给定石头重量数组 <code>stones</code>，每次选两块相撞（规则同题意），返回可能剩下的最小重量。</p></blockquote></li><li><p><strong>494. 目标和</strong></p><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>target</code>，在每个数前添加 <code>+</code> 或 <code>-</code>，返回使表达式结果等于 <code>target</code> 的方法数。</p></blockquote></li><li><p><strong>474. 一和零</strong></p><blockquote><p>给定二进制字符串数组 <code>strs</code> 和整数 <code>m</code>、<code>n</code>，在最多使用 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 的限制下，返回可选取字符串的最大数量。</p></blockquote></li><li><p><strong>279. 完全平方数</strong></p><blockquote><p>给定整数 <code>n</code>，返回和为 <code>n</code> 的完全平方数的最少数量。</p></blockquote></li><li><p><strong>139. 单词拆分</strong></p><blockquote><p>给定字符串 <code>s</code> 和字符串字典 <code>wordDict</code>，判断 <code>s</code> 是否能由字典中的单词拼接而成（单词可重复使用）。</p></blockquote></li><li><p><strong>198. 打家劫舍</strong></p><blockquote><p>给定非负整数数组 <code>nums</code> 表示每间房的金额，不能偷相邻房屋，返回可偷到的最大金额。</p></blockquote></li><li><p><strong>213. 打家劫舍 II</strong></p><blockquote><p>给定环形排列的房屋金额数组 <code>nums</code>，不能偷相邻房屋，返回可偷到的最大金额。</p></blockquote></li><li><p><strong>337. 打家劫舍 III</strong></p><blockquote><p>给定一棵二叉树（节点值为金额），不能同时偷父子节点，返回可偷到的最大金额。</p></blockquote></li><li><p><strong>121. 买卖股票的最佳时机</strong></p><blockquote><p>给定股票价格数组 <code>prices</code>，最多进行一次买卖，返回最大利润。</p></blockquote></li><li><p><strong>122. 买卖股票的最佳时机 II</strong></p><blockquote><p>给定股票价格数组 <code>prices</code>，可进行多次交易（同一时间只能持有一股），返回最大利润。</p></blockquote></li><li><p><strong>123. 买卖股票的最佳时机 III</strong></p><blockquote><p>给定股票价格数组 <code>prices</code>，最多进行两次交易，返回最大利润。</p></blockquote></li><li><p><strong>62. 不同路径</strong></p><blockquote><p>机器人从左上角到右下角，只能向右或向下移动，给定 <code>m</code> 和 <code>n</code>，返回不同路径数量。</p></blockquote></li><li><p><strong>63. 不同路径 II</strong></p><blockquote><p>与不同路径类似，但网格中有障碍物，返回从左上到右下的不同路径数量（无法到达则为 0）。</p></blockquote></li><li><p><strong>416. 分割等和子集</strong></p><blockquote><p>给定只包含正整数的数组 <code>nums</code>，判断是否可以将数组分割成两个子集，使两个子集元素和相等。</p></blockquote></li><li><p><strong>518. 零钱兑换 II</strong></p><blockquote><p>给定不同面额硬币 <code>coins</code> 和金额 <code>amount</code>，返回凑成 <code>amount</code> 的组合数（每种硬币数量无限）。</p></blockquote></li><li><p><strong>377. 组合总和 IV</strong></p><blockquote><p>给定不同整数数组 <code>nums</code> 和目标值 <code>target</code>，返回和为 <code>target</code> 的组合数（不同顺序视为不同组合）。</p></blockquote></li><li><p><strong>322. 零钱兑换</strong></p><blockquote><p>给定不同面额硬币 <code>coins</code> 和金额 <code>amount</code>，返回凑成 <code>amount</code> 所需的最少硬币数；若无法凑成返回 <code>-1</code>。</p></blockquote></li><li><p><strong>188. 买卖股票的最佳时机 IV</strong></p><blockquote><p>给定股票价格数组 <code>prices</code> 和整数 <code>k</code>，最多进行 <code>k</code> 次交易，返回最大利润。</p></blockquote></li><li><p><strong>309. 最佳买卖股票时机含冷冻期</strong></p><blockquote><p>给定股票价格数组 <code>prices</code>，可多次交易，但卖出后第二天为冷冻期不能买入，返回最大利润。</p></blockquote></li><li><p><strong>714. 买卖股票的最佳时机含手续费</strong></p><blockquote><p>给定股票价格数组 <code>prices</code> 和手续费 <code>fee</code>，可多次交易，每次卖出需支付手续费，返回最大利润。</p></blockquote></li><li><p><strong>1035. 不相交的线</strong></p><blockquote><p>给定两个整数数组 <code>nums1</code> 和 <code>nums2</code>，在不相交的前提下连接相等数字，返回可画的最大连线数。</p></blockquote></li><li><p><strong>392. 判断子序列</strong></p><blockquote><p>给定字符串 <code>s</code> 和 <code>t</code>，判断 <code>s</code> 是否为 <code>t</code> 的子序列。</p></blockquote></li><li><p><strong>115. 不同的子序列</strong></p><blockquote><p>给定字符串 <code>s</code> 和 <code>t</code>，返回 <code>s</code> 的子序列中等于 <code>t</code> 的不同子序列个数。</p></blockquote></li><li><p><strong>583. 两个字符串的删除操作</strong></p><blockquote><p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，每次可删除任意一个字符串中的一个字符，返回使两字符串相同所需的最少删除次数。</p></blockquote></li><li><p><strong>72. 编辑距离</strong></p><blockquote><p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，返回将 <code>word1</code> 转换为 <code>word2</code> 所需的最少操作数（插入、删除、替换）。</p></blockquote></li><li><p><strong>647. 回文子串</strong></p><blockquote><p>给定字符串 <code>s</code>，返回 <code>s</code> 中回文子串的数量。</p></blockquote></li><li><p><strong>516. 最长回文子序列</strong></p><blockquote><p>给定字符串 <code>s</code>，返回 <code>s</code> 的最长回文子序列长度。</p></blockquote></li></ul><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><ul><li><p><strong>300. 最长递增子序列</strong></p><blockquote><p>给定整数数组 <code>nums</code>，返回最长严格递增子序列的长度。</p></blockquote></li><li><p><strong>674. 最长连续递增序列</strong></p><blockquote><p>给定整数数组 <code>nums</code>，返回最长连续严格递增子序列的长度。</p></blockquote></li><li><p><strong>718. 最长重复子数组</strong></p><blockquote><p>给定两个整数数组 <code>nums1</code> 和 <code>nums2</code>，返回两个数组中公共的、长度最长的连续子数组长度。</p></blockquote></li><li><p><strong>1143. 最长公共子序列</strong></p><blockquote><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回它们的最长公共子序列长度。</p></blockquote></li><li><p><strong>739. 每日温度</strong></p><blockquote><p>给定整数数组 <code>temperatures</code>，返回一个数组 <code>answer</code>，其中 <code>answer[i]</code> 表示从第 <code>i</code> 天起需要等多少天才会有更高的温度；若之后都不会升温则为 <code>0</code>。</p></blockquote></li><li><p><strong>496. 下一个更大元素 I</strong></p><blockquote><p>给定两个没有重复元素的数组 <code>nums1</code> 和 <code>nums2</code>（<code>nums1</code> 是 <code>nums2</code> 的子集），对 <code>nums1</code> 中每个元素，找出其在 <code>nums2</code> 中对应位置右侧第一个比它大的元素；不存在则为 <code>-1</code>。</p></blockquote></li><li><p><strong>503. 下一个更大元素 II</strong></p><blockquote><p>给定一个循环数组 <code>nums</code>，返回每个元素的下一个更大元素；若不存在则为 <code>-1</code>。</p></blockquote></li><li><p><strong>42. 接雨水</strong></p><blockquote><p>给定非负整数数组 <code>height</code> 表示柱状图高度，计算按此排列能接到的雨水总量。</p></blockquote></li><li><p><strong>84. 柱状图中最大的矩形</strong></p><blockquote><p>给定非负整数数组 <code>heights</code> 表示柱状图每个柱子的高度，返回能够勾勒出的最大矩形面积。</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法理解</title>
      <link href="/2026/01/14/%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"/>
      <url>/2026/01/14/%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法："><a href="#排序算法：" class="headerlink" title="排序算法："></a>排序算法：</h1><h2 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h2><p>假设<code>[0,i)</code>已经排序好了，找到<code>[i,n)</code>最小数m，m和i交换。最多需要交换n-1次，最后一个自动最大</p><h2 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h2><p>相邻之间互相交换，小的在前面，大的再后面，最终实现最大的在最后面，达到冒泡效果。此时继续对<code>[0,n-1)</code>操作</p><h2 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h2><p>假设<code>[0,i)</code>已经排序好了，将i插入到要<code>[0,i)</code>里面，只需要给它挪一挪即可</p><h2 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h2><ul><li>先选择一个基点0，然后从1开始从左往右找第一个比<code>c[0]</code>大的数。同时从n-1开始从右往左找第一个比<code>c[0]</code>小的数，找到以后，这两个数进行交换。然后继续找第二个，直到左指针右指针<code>i=j</code>重合。此时交换0和重合位置i (哨兵)。最终实现i的左边的数 &lt;&#x3D; <code>c[i]</code> &lt;&#x3D; i的右边的数</li><li>获得这个哨兵，然后分别递归<code>[0,i)</code>,<code>[i+1,n)</code>即可</li></ul><h2 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h2><ul><li>递：不断对区间一分为二</li><li>归：用新数组整理最小的区间对应的顺序，一步步向上归<ul><li>采用后序遍历方式，先求出中点，然后递归左边，递归右边，最后合并</li><li>合并：构建一个临时数组，按顺序放目标数组（递完以后的子数组）的数字，然后复制到目标数组的位置上面去</li><li>这样子一步步从小到大进行重排</li></ul></li></ul><h2 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h2><ul><li><p>堆：完全二叉树结构 + 任意节点的值<code>&lt;=(&gt;=)</code>其子节点的值被称为小顶堆(大顶堆)</p><ul><li>完全二叉树仅允许最底层的节点不完全填满，且最底层的节点必须从左至右依次连续填充</li><li>小顶堆大顶堆的区别只是堆化操作时的比较交换不同</li><li>这里的堆由数组实现<ul><li>当使用数组表示二叉树时,元素代表节点值,索引代表节点在二叉树中的位置。节点指针通过索引映射公式来实现。给定索引i,其左子节点的索引为<code>2i+1</code>,右子节点的索引为<code>2i+2</code>,父节点的索引为<code>(i-1)/2</code>(向下整除)。当索引越界时,表示空节点或节点不存在。</li></ul></li></ul></li><li><p>堆的基础知识：</p><ul><li>节点入堆出堆操作<ul><li>入堆（自底向上）：首先加到末尾点，找到父节点，比较交换。以此类推直到交换到根节点。时间复杂度为<code>O(log n)</code></li><li>出堆（自顶向下）：这里出堆是出根节点。那就交换根节点和尾节点，然后删除交换后的尾节点。然后对根节点进行自顶向下的堆化操作来保持堆结构。目标是找到最小数，然后挪到堆顶。那么就从根节点开始，比较该节点和它的左右子节点的值，看看哪一个最小，把最小的和当前节点进行交换。然后向下遍历即可。时间复杂度为<code>O(log n)</code></li></ul></li><li>小顶堆构建方式1：建立空堆后一个个入堆<code>O(log n)</code>，节点从顶到底依次被添加。时间复杂度为<code>O(nlog n)</code></li><li>小顶堆构建方式2：将列表原封不动添加到二叉树中O(n)，倒序遍历节点<code>for (int i = parent(size() - 1); i &gt;= 0; i--) </code>，然后一个个执行自顶向下的堆化操作，此时不用管叶节点，<strong>时间复杂度降低至O(n)</strong><ul><li>为了降低计算难度,假没给定一个节点数量为n、高度为h的”完美二叉树”,该假设不会影响计算结果的正确性</li><li>高度为$h-k$那一行的节点交换次数为$2^{h-k}(h-k)$，其中$2^{h-k}$是该行节点数目，$h-k$是交换次数<br>   $$<br>   T(h)&#x3D;2^0h+2^1(h-1)+2^2(h-2)+…+2^{h-1} &#x3D; O(2^h) &#x3D; O(n)<br>   $$</li></ul></li></ul></li><li><p>堆排序的不同做法</p><ul><li>在原数组堆化操作，采取小顶堆构建方式2<ul><li>堆化以后，一个个出堆，<strong>需要额外数组保存出堆结果</strong></li></ul></li><li>直接在这个数组操作并返回这个小顶堆：先建立大顶堆O(n)，然后将堆顶和尾节点交换<code>for (int i = nums.length - 1; i &gt; 0; i--)</code> ，然后删除这个尾节点（逻辑删除），然后堆顶进行自顶而下的堆化操作。本质就是出堆操作，时间复杂度为<code>n O(log n)</code>。</li></ul></li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ul><li>设置一些具有大小顺序的桶,每个桶对应一个数据范围,将数据平均分配到各个桶中;然后,在每个桶内部分别执行排序;最终按照桶的顺序将所有数据合并。<ul><li>初始化k个桶,将n个元素分配到k个桶中。<ul><li>这一步是关键：将数组的值nums[i]映射到桶的索引</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Float&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) (num * k);</span><br><span class="line"><span class="comment">// 将 num 添加进桶 i</span></span><br><span class="line">buckets.get(i).add(num);</span><br></pre></td></tr></table></figure></li><li>对每个桶分别执行排序(这里采用编程语言的内置排序函数)。</li><li>按照桶从小到大的顺序遍历合并结果。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
